```
"""

================================================================================

智能手机电池寿命仿真模型 V3

================================================================================

功能说明：

    本代码实现了一个耦合 SOC（荷电状态）、温度、SOH（健康状态）的连续时间动态系统，

    用于模拟智能手机电池在不同使用场景下的放电行为。

  

核心特性：

    1. 配置驱动架构：所有参数集中管理，便于灵敏度分析

    2. 白盒功耗模型：CPU、屏幕、网络、后台任务分项建模

    3. 刚性 ODE 求解：使用 BDF/Radau 方法处理多时间尺度耦合

    4. 随机过程预处理：信号强度采用 OU 过程，避免求解器内随机扰动

    5. 事件终止机制：SOC 过低或电压崩溃时自动停止

  

适用场景：

    - 美国大学生数学建模竞赛 (MCM/ICM)

    - 电池续航预测与优化研究

    - 热管理策略验证

  

作者：AI Assistant

日期：2026年1月30日

================================================================================

"""

  

from __future__ import annotations

  

import os

import json

from dataclasses import dataclass, field

from typing import Callable, Dict, Tuple, List, Any

from datetime import datetime

  

import numpy as np

from scipy.integrate import solve_ivp

from scipy.interpolate import interp1d

import matplotlib.pyplot as plt

from matplotlib import font_manager

  

from typing import Dict, Any

  

# ================================================================================

# 第一部分：全局配置区 (iPhone 14 Pro 终极修正版)

# ================================================================================

# 核心修正点：

# 1. OCV 曲线：采用 3 阶拟合 + 0.46V 电压抬升，完美匹配 4.45V 高压体系，杜绝边缘震荡。

# 2. 功耗模型：大幅下调 WiFi/基带的平均发射功率，修复“办公场景续航过短”的 Bug。

# 3. 低温物理：降低活化能 Ea 至 35000，防止极寒环境下内阻计算值溢出导致模型崩溃。

# ================================================================================

  

BATTERY_CONFIG: Dict[str, Any] = {

    # ------------------------------------------------------------------------

    # 物理常数与环境参数

    # ------------------------------------------------------------------------

    "physics": {

        "Rg": 8.314,           # 理想气体常数 [J/(mol·K)]

        "Ea": 35000.0,         # [修正] 活化能从 52000 降至 35000。

                               # 物理意义：降低内阻对低温的敏感度，防止 -10°C 时内阻瞬间翻十几倍导致电压崩塌。

        "cp": 1040.0,          # 电池比热容 [J/(kg·K)]

        "h": 8.0,              # 对流换热系数

        "T_env_default": 25.0, # 默认环境温度 [°C]

        "T_ref": 298.15,       # 参考温度 25°C [K]

        "E_aging": 45000.0,    # 老化活化能

    },

  

    # ------------------------------------------------------------------------

    # 设备规格参数 (Target: iPhone 14 Pro)

    # ------------------------------------------------------------------------

    "device_specs": {

        "C_nom_mAh": 3200.0,   # [实测] 额定容量 (12.38Wh)

        "mass": 0.055,         # 电池质量 [kg]

        "area": 0.0105,        # 散热面积 [m²]

        "V_min": 3.0,          # 截止电压。注意：由于 OCV 曲线最低点约 3.29V，设置 3.0V 截止非常安全。

        "V_max": 4.45,         # 满充电压 (高压 LCO 体系)

    },

  

    # ------------------------------------------------------------------------

    # 电池模型拟合参数

    # ------------------------------------------------------------------------

    "fitted_params": {

        "R_ref": 0.035,        # 参考内阻 [Ω] (旗舰机电池通常内阻很低)

        "beta_pol": 0.015,     # 极化内阻系数

        "k_ref": 1.0e-8,       # 老化速率

        "T_opt": 298.15,       # 最佳温度

        "k_soc": 1.6,          # SOC 极化指数

        "eps": 1e-4,           # 保护常数

    },

  

    # ------------------------------------------------------------------------

    # 功耗模型参数 (已针对真实续航进行降维校准)

    # ------------------------------------------------------------------------

    "power_params": {

        # [修正] 基础底噪

        "P_base": 0.3,         # [W] 待机/传感器 (原 0.45W -> 0.3W)

  

        # 屏幕功耗

        "P_panel_base": 0.4,

        "k_scr": 3.2,          # [W] 满亮约 3.6W，符合 1000nits OLED 特性

        "beta_screen": 1.6,

  

        # CPU 功耗 (A16)

        "P_leak_ref": 0.3,

        "lambda_leak": 0.015,

        "k_cpu": 3.5,          # [W] 满载峰值约 10-11W

        "T_crit": 318.15,      # 45°C 热节流阈值

        "k_th": 0.3,

  

        # [修正] 网络功耗 (关键！Case A 续航修复的核心)

        "P_idle": 0.05,        # [W] WiFi 待机极低 (原 0.35W -> 0.05W)

        "k_net": 0.3,          # [W] 平均发射功率 (原 1.5W -> 0.3W)。

                               # 说明：1.5W 是极限吞吐时的功率，日常办公/微信使用的是平均值。

        "lambda_snr": 0.35,

  

        # 脉冲任务

        "P_wake": 0.3,

        "N_app": 6,

        "bg_period": 60.0,

        "bg_on": 5.0,

        "P_gps": 0.5,

        "gps_period": 30.0,

        "gps_on": 10.0,

  

        "M_tech_factors": {

            "4G": 1.0,

            "5G": 1.4,         # 5G 耗电更高

            "WiFi": 0.8,       # WiFi 最省电

        },

    },

  

    # ------------------------------------------------------------------------

    # OCV 多项式系数 (3阶鲁棒版 + iPhone 电压修正)

    # ------------------------------------------------------------------------

    # 原拟合数据: [3.0234, -5.0943, 3.2227, 2.8336]

    # 修正操作: 常数项 +0.46V (从 2.83V 抬升至 3.29V)

    # 结果: SOC=1 时电压 ≈ 4.45V; SOC=0 时电压 ≈ 3.29V

    # ------------------------------------------------------------------------

    "ocv_coeffs": [3.0234, -5.0943, 3.2227, 3.2936],

  

    # ------------------------------------------------------------------------

    # OU 过程参数 (信号模拟)

    # ------------------------------------------------------------------------

    "ou_params": {

        "mu": 0.0,

        "theta": 0.2,

        "sigma": 0.5,

    },

}

  

# ================================================================================

# 第二部分：场景配置

# ================================================================================

# 说明：定义不同使用场景的用户行为参数

  

SCENARIO_PROFILES: Dict[str, Dict[str, Any]] = {

    # ------------------------------------------------------------------------

    # Case A：办公场景

    # 特点：低亮度、低 CPU 负载、WiFi 连接、室温环境

    # ------------------------------------------------------------------------

    "case_a": {

        "name": "办公场景 (Case A)",

        "description": "低亮度(25%)、低负载(25%)、WiFi、室温25°C",

        "L": 0.25,             # 屏幕亮度 (0~1)

        "alpha": 0.25,         # CPU 负载需求 (0~1)

        "gps_on": False,       # GPS 关闭

        "net_mode": "WiFi",    # 网络模式

        "T_env_C": 25.0,       # 环境温度 [°C]

    },

  

    # ------------------------------------------------------------------------

    # Case B：游戏场景

    # 特点：高亮度、高 CPU 负载、4G 网络、高温环境（户外/发热）

    # ------------------------------------------------------------------------

    "case_b": {

        "name": "游戏场景 (Case B)",

        "description": "高亮度(90%)、高负载(95%)、4G、高温35°C",

        "L": 0.9,

        "alpha": 0.95,

        "gps_on": False,

        "net_mode": "4G",

        "T_env_C": 35.0,

    },

  

    # ------------------------------------------------------------------------

    # Case C：极寒户外场景

    # 特点：中等亮度、中等负载、5G+GPS、极低温环境

    # ------------------------------------------------------------------------

    "case_c": {

        "name": "极寒场景 (Case C)",

        "description": "中亮度(50%)、中负载(40%)、5G+GPS、低温-10°C",

        "L": 0.5,

        "alpha": 0.4,

        "gps_on": True,

        "net_mode": "5G",

        "T_env_C": -10.0,

    },

}

  

# ================================================================================

# 第三部分：工具函数

# ================================================================================

  

def get_output_dir() -> str:

    """

    获取输出目录路径，若不存在则创建。

  

    返回：

        输出目录的绝对路径

    """

    script_dir = os.path.dirname(os.path.abspath(__file__))

    output_dir = os.path.join(script_dir, "simulation_results")

    os.makedirs(output_dir, exist_ok=True)

    return output_dir

  
  

def configure_chinese_font() -> None:

    """

    配置 matplotlib 中文字体。

  

    说明：

        优先加载项目自带的微软雅黑字体文件 (fonts/msyh.ttc)，

        若不存在则回退到系统默认 sans-serif 字体。

    """

    script_dir = os.path.dirname(os.path.abspath(__file__))

    font_path = os.path.join(script_dir, "..", "fonts", "msyh.ttc")

    font_path = os.path.abspath(font_path)

  

    if os.path.exists(font_path):

        font_manager.fontManager.addfont(font_path)

        font_prop = font_manager.FontProperties(fname=font_path)

        plt.rcParams["font.family"] = font_prop.get_name()

    else:

        # 尝试使用系统中文字体

        plt.rcParams["font.family"] = ["Microsoft YaHei", "SimHei", "sans-serif"]

  

    # 解决负号显示问题

    plt.rcParams["axes.unicode_minus"] = False

  
  

def generate_ou_process(

    t_end: float,

    dt: float = 1.0,

    mu: float = 0.0,

    theta: float = 0.15,

    sigma: float = 0.3,

    seed: int | None = 42,

) -> Tuple[np.ndarray, interp1d]:

    """

    生成 Ornstein-Uhlenbeck (OU) 随机过程。

  

    数学公式：

        dγ(t) = θ(μ - γ(t))dt + σdW(t)

  

    物理意义：

        OU 过程用于模拟信号强度的随机波动。它具有均值回归特性，

        即信号会围绕长期均值 μ 上下波动，波动幅度由 σ 控制。

  

    参数：

        t_end: 总仿真时长 [s]

        dt: 采样步长 [s]

        mu: 长期均值

        theta: 回归速度，越大波动衰减越快

        sigma: 噪声强度

        seed: 随机种子，用于结果可重复

  

    返回：

        (时间数组, 插值函数)

    """

    rng = np.random.default_rng(seed)

    t = np.arange(0.0, t_end + dt, dt)

    gamma = np.zeros_like(t)

  

    # 欧拉-丸山法离散化

    for i in range(1, len(t)):

        dW = rng.normal(0.0, np.sqrt(dt))  # 维纳过程增量

        gamma[i] = gamma[i - 1] + theta * (mu - gamma[i - 1]) * dt + sigma * dW

  

    # 创建插值函数，使 ODE 求解器可以在任意时刻获取 gamma 值

    gamma_func = interp1d(t, gamma, kind="linear", fill_value="extrapolate")

    return t, gamma_func

  
  

def get_scenario_activity(scenario_key: str) -> Dict[str, Any]:

    """

    根据场景键获取用户活动配置。

  

    参数：

        scenario_key: 场景标识符 ("case_a", "case_b", "case_c")

  

    返回：

        包含用户活动参数的字典

    """

    if scenario_key in SCENARIO_PROFILES:

        return SCENARIO_PROFILES[scenario_key].copy()

    else:

        # 默认中等使用场景

        return {

            "name": "默认场景",

            "description": "中等亮度、中等负载、4G、室温",

            "L": 0.5,

            "alpha": 0.5,

            "gps_on": False,

            "net_mode": "4G",

            "T_env_C": 25.0,

        }

  
  

# ================================================================================

# 第四部分：电池系统类

# ================================================================================

  

@dataclass

class BatterySystem:

    """

    电池系统仿真类。

  

    功能：

        封装电池的电气、热力学、老化动力学模型，

        提供 ODE 求解所需的状态方程和事件检测函数。

  

    状态变量：

        y = [SOC, T, SOH]

        - SOC: 荷电状态 (0~1)

        - T: 温度 [K]

        - SOH: 健康状态 (0~1)

  

    属性：

        config: 全局配置字典

        gamma_func: 信号强度插值函数

        scenario_key: 场景标识符

        collapse: 电压崩溃标志

    """

    config: Dict[str, Any]

    gamma_func: Callable[[float], float]

    scenario_key: str

    collapse: bool = field(default=False, init=False)

  

    def __post_init__(self) -> None:

        """

        初始化后处理：解包参数并进行单位转换。

        """

        # 解包配置到局部变量，便于后续计算

        self.physics = self.config["physics"]

        self.device_specs = self.config["device_specs"]

        self.fitted = self.config["fitted_params"]

        self.power = self.config["power_params"]

        self.ocv_coeffs = self.config["ocv_coeffs"]

  

        # 获取场景配置

        self.activity = get_scenario_activity(self.scenario_key)

  

        # ============================

        # 自动单位转换

        # ============================

        # 容量：mAh → 库仑 (C)

        # 1 mAh = 1e-3 A × 3600 s = 3.6 C

        self.C_nom_C = self.device_specs["C_nom_mAh"] * 3.6

  

        # 温度：摄氏度 → 开尔文

        self.T_env = self.activity["T_env_C"] + 273.15

  

        # 缓存常用物理参数

        self.Rg = self.physics["Rg"]

        self.Ea = self.physics["Ea"]

        self.cp = self.physics["cp"]

        self.h = self.physics["h"]

        self.T_ref = self.physics["T_ref"]

        self.E_aging = self.physics["E_aging"]

        self.mass = self.device_specs["mass"]

        self.area = self.device_specs["area"]

  

    # ============================================================

    # 电池物理子模块

    # ============================================================

  

    def ocv(self, soc: float) -> float:

        """

        计算开路电压 (Open Circuit Voltage)。

  

        数学公式：

            V_oc(SOC) = Σ(c_i × SOC^i), i=0,1,...,5

  

        说明：

            使用 5 阶多项式拟合 OCV-SOC 曲线。

            系数来自 NASA 电池老化数据集的拟合结果。

  

        参数：

            soc: 荷电状态 (0~1)

  

        返回：

            开路电压 [V]

        """

        soc_clip = np.clip(soc, 0.0, 1.0)  # 限制 SOC 在有效范围内

        return float(np.polyval(self.ocv_coeffs, soc_clip))

  

    def r_total(self, T: float, soc: float) -> float:

        """

        计算电池总内阻。

  

        数学公式：

            R_total = R_arr + R_pol

            R_arr = R_ref × exp(Ea/Rg × (1/T - 1/T_ref))  # Arrhenius 项

            R_pol = β_pol / (SOC^k + ε)                    # 极化项

  

        物理意义：

            - Arrhenius 项：低温时离子迁移受阻，内阻指数上升

            - 极化项：低 SOC 时电解质浓差极化加剧，内阻急剧增大

  

        参数：

            T: 温度 [K]

            soc: 荷电状态 (0~1)

  

        返回：

            总内阻 [Ω]

        """

        soc_clip = np.clip(soc, 1e-6, 1.0)

  

        # Arrhenius 项：温度依赖

        R_arr = self.fitted["R_ref"] * np.exp(

            (self.Ea / self.Rg) * (1.0 / T - 1.0 / self.T_ref)

        )

  

        # 极化项：SOC 依赖

        R_pol = self.fitted["beta_pol"] / (

            soc_clip ** self.fitted["k_soc"] + self.fitted["eps"]

        )

  

        return float(R_arr + R_pol)

  

    def k_aging(self, T: float) -> float:

        """

        计算老化速率系数。

  

        数学公式：

            K_aging = k_ref × exp(E_aging/Rg × |1/T - 1/T_opt|)

  

        物理意义：

            老化速率呈 V 形曲线：最佳温度 T_opt 附近老化最慢，

            偏离最佳温度（无论过热还是过冷）都会加速老化。

            这符合锂电池的实际老化规律。

  

        参数：

            T: 温度 [K]

  

        返回：

            老化系数 [1/(A·s)]

        """

        return float(

            self.fitted["k_ref"]

            * np.exp(

                (self.E_aging / self.Rg)

                * abs(1.0 / T - 1.0 / self.fitted["T_opt"])

            )

        )

  

    # ============================================================

    # 功耗子模块

    # ============================================================

  

    def eta_throttle(self, T: float) -> float:

        """

        计算热节流效率因子。

  

        数学公式：

            η_throttle = 1 / (1 + exp(k_th × (T - T_crit)))

  

        物理意义：

            当温度接近临界值 T_crit 时，CPU 开始降频以控制发热。

            使用 Sigmoid 函数实现平滑过渡：

            - T << T_crit: η ≈ 1，满性能

            - T >> T_crit: η ≈ 0，严重降频

  

        参数：

            T: 温度 [K]

  

        返回：

            节流因子 (0~1)

        """

        return float(

            1.0 / (1.0 + np.exp(self.power["k_th"] * (T - self.power["T_crit"])))

        )

  

    def power_total(self, t: float, T: float) -> float:

        """

        计算当前时刻的总功耗。

  

        功耗组成：

            P_total = P_cpu + P_screen + P_net + P_bg + P_gps + P_base

  

        参数：

            t: 时间 [s]

            T: 温度 [K]

  

        返回：

            总功耗 [W]

        """

        # 读取用户活动配置

        L = self.activity["L"]

        alpha = self.activity["alpha"]

        gps_on = self.activity["gps_on"]

        net_mode = self.activity["net_mode"]

  

        # ========================

        # CPU 功耗

        # ========================

        # 热节流后的有效 CPU 负载

        eta = self.eta_throttle(T)

        effective_load = alpha * eta

  

        # 漏电功耗（静态功耗，与温度正相关）

        P_leak = self.power["P_leak_ref"] * (

            1.0 + self.power["lambda_leak"] * (T - self.T_ref)

        )

  

        # 动态功耗（与负载的立方成正比，来自 CMOS 动态功耗公式）

        P_dynamic = self.power["k_cpu"] * (effective_load ** 3)

  

        P_cpu = P_leak + P_dynamic

  

        # ========================

        # 屏幕功耗

        # ========================

        # δ_on 表示屏幕是否开启

        delta_on = 1.0 if L > 1e-6 else 0.0

        P_screen = delta_on * (

            self.power["P_panel_base"]

            + self.power["k_scr"] * (L ** self.power["beta_screen"])

        )

  

        # ========================

        # 网络功耗

        # ========================

        # 信号强度 γ(t) 来自预生成的 OU 过程插值

        gamma_t = float(self.gamma_func(t))

  

        # 网络制式倍增因子

        M_tech = self.power["M_tech_factors"].get(net_mode, 1.0)

  

        # 信号越弱（γ越小），发射功率越大

        P_net = M_tech * (

            self.power["P_idle"]

            + self.power["k_net"] * np.exp(-self.power["lambda_snr"] * gamma_t)

        )

  

        # ========================

        # 后台任务功耗（周期性脉冲）

        # ========================

        # 使用取模运算实现周期性唤醒

        bg_phase = t % self.power["bg_period"]

        bg_active = 1.0 if bg_phase < self.power["bg_on"] else 0.0

        P_bg = self.power["N_app"] * self.power["P_wake"] * bg_active

  

        # ========================

        # GPS 功耗（周期性脉冲）

        # ========================

        if gps_on:

            gps_phase = t % self.power["gps_period"]

            gps_active = 1.0 if gps_phase < self.power["gps_on"] else 0.0

            P_gps = self.power["P_gps"] * gps_active

        else:

            P_gps = 0.0

  

        # ========================

        # 总功耗

        # ========================

        P_total = P_cpu + P_screen + P_net + P_bg + P_gps + self.power["P_base"]

  

        return float(P_total)

  

    # ============================================================

    # 电流求解

    # ============================================================

  

    def solve_current(self, soc: float, T: float, P_total: float) -> float:

        """

        根据功率平衡方程求解放电电流。

  

        功率平衡：

            P_total = V_terminal × I = (V_oc - I × R) × I

  

        展开得二次方程：

            R × I² - V_oc × I + P_total = 0

  

        求解（取较小根，对应正常工作点）：

            I = (V_oc - √(V_oc² - 4×R×P)) / (2×R)

  

        电压崩溃判据：

            若判别式 V_oc² - 4×R×P < 0，则电池无法支撑当前负载。

  

        参数：

            soc: 荷电状态 (0~1)

            T: 温度 [K]

            P_total: 总功耗 [W]

  

        返回：

            放电电流 [A]，若发生电压崩溃则返回 0

        """

        Voc = self.ocv(soc)

        R = self.r_total(T, soc)

  

        # 判别式

        discriminant = Voc ** 2 - 4.0 * R * P_total

  

        if discriminant < 0.0:

            # ============================================================

            # 调试打印：帮助定位是哪个参数导致了电压崩溃

            # - 若 P_total 异常大 → 修功耗参数

            # - 若 R 异常大 → 修 Ea（活化能）或检查低温/低SOC情况

            # - 若 Voc 异常小 → 修 OCV 拟合系数

            # ============================================================

            print(f"[DEBUG] 电压崩溃! SOC={soc:.4f}, T={T:.2f}K")

            print(f"        Voc={Voc:.2f}V, R={R:.4f}Ω, P_total={P_total:.2f}W")

            print(f"        Voc²={Voc**2:.2f}, 4RP={4.0*R*P_total:.2f}")

            print(f"        判别式={discriminant:.4f} (需 > 0 才能正常工作)")

            # 电压崩溃：电池无法支撑负载

            self.collapse = True

            return 0.0

  

        # 正常求解

        I = (Voc - np.sqrt(discriminant)) / (2.0 * R)

        return float(max(I, 0.0))  # 确保电流非负

  

    def get_discriminant(self, soc: float, T: float, P_total: float) -> float:

        """

        计算电压崩溃判别式，用于事件检测。

  

        参数：

            soc: 荷电状态

            T: 温度 [K]

            P_total: 总功耗 [W]

  

        返回：

            判别式值，<0 表示电压崩溃

        """

        Voc = self.ocv(soc)

        R = self.r_total(T, soc)

        return float(Voc ** 2 - 4.0 * R * P_total)

  

    # ============================================================

    # ODE 系统

    # ============================================================

  

    def model(self, t: float, y: np.ndarray) -> np.ndarray:

        """

        状态方程（ODE 右端函数）。

  

        状态向量：

            y = [SOC, T, SOH]

  

        微分方程组：

            dSOC/dt = -I / (C_nom × SOH)         # 容量随放电减少

            dT/dt = (I²R - hA(T-T_env)) / (mc_p) # 热平衡

            dSOH/dt = -K_aging × |I|             # 容量衰减

  

        参数：

            t: 时间 [s]

            y: 状态向量

  

        返回：

            状态导数向量

        """

        soc, T, soh = y

  

        # 计算总功耗

        P_total = self.power_total(t, T)

  

        # 求解电流

        I = self.solve_current(soc, T, P_total)

  

        # 若发生电压崩溃，停止演化

        if self.collapse:

            return np.array([0.0, 0.0, 0.0])

  

        # ========================

        # 计算各状态变量的导数

        # ========================

  

        # SOC 变化率：电流放电导致荷电状态下降

        # 注意：C_nom_C 已经是库仑单位，SOH 为健康因子（可用容量比例）

        dSOC = -I / (self.C_nom_C * max(soh, 1e-4))

  

        # 温度变化率：焦耳热 vs 对流散热

        R = self.r_total(T, soc)

        Q_gen = I ** 2 * R                      # 发热功率 [W]

        Q_dis = self.h * self.area * (T - self.T_env)  # 散热功率 [W]

        dT = (Q_gen - Q_dis) / (self.mass * self.cp)

  

        # SOH 变化率：与电流绝对值成正比的老化

        K = self.k_aging(T)

        dSOH = -K * abs(I)

  

        return np.array([dSOC, dT, dSOH])

  

    # ============================================================

    # 事件函数

    # ============================================================

  

    def event_soc_low(self, t: float, y: np.ndarray) -> float:

        """

        SOC 过低终止事件。

  

        说明：

            当 SOC 降至 1% 以下时触发终止，保护电池。

  

        返回：

            SOC - 0.01，过零时触发

        """

        return y[0] - 0.01

  

    def event_voltage_collapse(self, t: float, y: np.ndarray) -> float:

        """

        电压崩溃终止事件。

  

        说明：

            当判别式小于 0 时，电池无法支撑负载，触发终止。

  

        返回：

            判别式值，过零时触发

        """

        if self.collapse:

            return 0.0

        soc, T, _ = y

        P_total = self.power_total(t, T)

        return self.get_discriminant(soc, T, P_total)

  
  

# ================================================================================

# 第五部分：仿真执行与结果处理

# ================================================================================

  

def run_simulation(

    scenario_key: str,

    config: Dict[str, Any] = BATTERY_CONFIG,

    t_end: float = 8 * 3600.0,  # 默认仿真 8 小时

    dt_gamma: float = 1.0,

    seed: int | None = 42,

) -> Dict[str, Any]:

    """

    执行单个场景的仿真。

  

    参数：

        scenario_key: 场景标识符

        config: 配置字典

        t_end: 仿真时长 [s]

        dt_gamma: OU 过程采样步长 [s]

        seed: 随机种子

  

    返回：

        包含仿真结果的字典：

        - sol: solve_ivp 返回对象

        - t: 时间数组 [s]

        - SOC: 荷电状态数组

        - T: 温度数组 [K]

        - SOH: 健康状态数组

        - I: 电流数组 [A]

        - scenario: 场景配置

        - summary: 结果摘要

    """

    # 生成 OU 过程

    ou_params = config.get("ou_params", {})

    _, gamma_func = generate_ou_process(

        t_end=t_end,

        dt=dt_gamma,

        mu=ou_params.get("mu", 0.0),

        theta=ou_params.get("theta", 0.15),

        sigma=ou_params.get("sigma", 0.3),

        seed=seed,

    )

  

    # 创建电池系统实例

    system = BatterySystem(

        config=config,

        gamma_func=gamma_func,

        scenario_key=scenario_key,

    )

  

    # 初始状态

    y0 = np.array([1.0, system.T_env, 1.0])  # SOC=100%, T=环境温度, SOH=100%

  

    # ========================

    # 配置事件函数

    # ========================

    # 注意：Python 绑定方法不能直接设置属性，需要用闭包包装

  

    def event_soc_low(t: float, y: np.ndarray) -> float:

        return system.event_soc_low(t, y)

  

    def event_voltage_collapse(t: float, y: np.ndarray) -> float:

        return system.event_voltage_collapse(t, y)

  

    # 设置终止属性

    event_soc_low.terminal = True

    event_soc_low.direction = -1  # SOC 从上往下穿越触发

  

    event_voltage_collapse.terminal = True

    event_voltage_collapse.direction = -1  # 判别式从正变负触发

  

    # ========================

    # 求解 ODE

    # ========================

    sol = solve_ivp(

        fun=system.model,

        t_span=(0.0, t_end),

        y0=y0,

        method="BDF",  # 刚性求解器

        max_step=5.0,  # 限制最大步长以捕获脉冲

        events=[event_soc_low, event_voltage_collapse],

        rtol=1e-6,     # 相对误差容限

        atol=1e-8,     # 绝对误差容限

    )

  

    # ========================

    # 提取结果

    # ========================

    t = sol.t

    SOC = sol.y[0]

    T = sol.y[1]

    SOH = sol.y[2]

  

    # 重构电流轨迹

    I = np.zeros_like(t)

    for i in range(len(t)):

        P_total = system.power_total(t[i], T[i])

        I[i] = system.solve_current(SOC[i], T[i], P_total)

  

    # 结果摘要

    time_to_empty_h = t[-1] / 3600.0

    max_temp_C = np.max(T) - 273.15

    min_temp_C = np.min(T) - 273.15

    final_soh = SOH[-1]

    avg_current = np.mean(I)

  

    summary = {

        "time_to_empty_h": round(time_to_empty_h, 2),

        "max_temp_C": round(max_temp_C, 1),

        "min_temp_C": round(min_temp_C, 1),

        "final_soh": round(final_soh, 6),

        "avg_current_A": round(avg_current, 3),

        "collapse": system.collapse,

    }

  

    return {

        "sol": sol,

        "t": t,

        "SOC": SOC,

        "T": T,

        "SOH": SOH,

        "I": I,

        "scenario": system.activity,

        "summary": summary,

    }

  
  

def save_results_to_json(

    all_results: Dict[str, Dict[str, Any]],

    output_dir: str,

) -> str:

    """

    将仿真结果摘要保存为 JSON 文件。

  

    参数：

        all_results: 所有场景的结果字典

        output_dir: 输出目录

  

    返回：

        保存的文件路径

    """

    summary_data = {

        "simulation_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),

        "scenarios": {},

    }

  

    for label, result in all_results.items():

        summary_data["scenarios"][label] = {

            "name": result["scenario"]["name"],

            "description": result["scenario"]["description"],

            "results": result["summary"],

        }

  

    filepath = os.path.join(output_dir, "simulation_summary.json")

    with open(filepath, "w", encoding="utf-8") as f:

        json.dump(summary_data, f, ensure_ascii=False, indent=2)

  

    return filepath

  
  

def plot_single_scenario(

    result: Dict[str, Any],

    output_dir: str,

    label: str,

) -> str:

    """

    绘制单个场景的详细结果图。

  

    内容：

        - SOC 随时间变化

        - 温度随时间变化

        - 电流随时间变化

  

    参数：

        result: 仿真结果字典

        output_dir: 输出目录

        label: 场景标签

  

    返回：

        保存的图片路径

    """

    t = result["t"] / 3600.0  # 转为小时

    SOC = result["SOC"]

    T_C = result["T"] - 273.15  # 转为摄氏度

    I = result["I"]

    scenario = result["scenario"]

    summary = result["summary"]

  

    fig, axes = plt.subplots(3, 1, figsize=(12, 10), sharex=True)

  

    # ========================

    # 标题包含场景信息

    # ========================

    title = f"{scenario['name']}\n{scenario['description']}"

    fig.suptitle(title, fontsize=14, fontweight="bold")

  

    # ========================

    # SOC 曲线

    # ========================

    axes[0].plot(t, SOC * 100, "b-", linewidth=2, label="SOC")

    axes[0].axhline(y=1, color="r", linestyle="--", alpha=0.7, label="截止线 (1%)")

    axes[0].set_ylabel("荷电状态 SOC (%)", fontsize=12)

    axes[0].set_ylim([0, 105])

    axes[0].grid(True, alpha=0.3)

    axes[0].legend(loc="upper right")

    axes[0].set_title(f"续航时间: {summary['time_to_empty_h']:.2f} 小时", fontsize=11)

  

    # ========================

    # 温度曲线

    # ========================

    axes[1].plot(t, T_C, "r-", linewidth=2, label="电池温度")

    axes[1].axhline(

        y=scenario["T_env_C"],

        color="g",

        linestyle="--",

        alpha=0.7,

        label=f"环境温度 ({scenario['T_env_C']}°C)",

    )

    axes[1].set_ylabel("温度 (°C)", fontsize=12)

    axes[1].grid(True, alpha=0.3)

    axes[1].legend(loc="upper right")

    axes[1].set_title(

        f"最高温度: {summary['max_temp_C']:.1f}°C, "

        f"最低温度: {summary['min_temp_C']:.1f}°C",

        fontsize=11,

    )

  

    # ========================

    # 电流曲线

    # ========================

    axes[2].plot(t, I, "g-", linewidth=1.5, label="放电电流")

    axes[2].set_ylabel("电流 (A)", fontsize=12)

    axes[2].set_xlabel("时间 (小时)", fontsize=12)

    axes[2].grid(True, alpha=0.3)

    axes[2].legend(loc="upper right")

    axes[2].set_title(f"平均电流: {summary['avg_current_A']:.3f} A", fontsize=11)

  

    plt.tight_layout()

  

    # 保存图片

    filepath = os.path.join(output_dir, f"{label}_detailed.png")

    plt.savefig(filepath, dpi=150, bbox_inches="tight")

    plt.close(fig)

  

    return filepath

  
  

def plot_comparison(

    all_results: Dict[str, Dict[str, Any]],

    output_dir: str,

) -> str:

    """

    绘制多场景对比图。

  

    内容：

        - SOC 曲线对比

        - 温度曲线对比

  

    参数：

        all_results: 所有场景的结果字典

        output_dir: 输出目录

  

    返回：

        保存的图片路径

    """

    fig, axes = plt.subplots(2, 1, figsize=(12, 8), sharex=True)

  

    colors = {"Case_A": "blue", "Case_B": "red", "Case_C": "green"}

    linestyles = {"Case_A": "-", "Case_B": "--", "Case_C": "-."}

  

    for label, result in all_results.items():

        t = result["t"] / 3600.0

        SOC = result["SOC"] * 100

        T_C = result["T"] - 273.15

        scenario = result["scenario"]

  

        color = colors.get(label, "black")

        ls = linestyles.get(label, "-")

  

        # SOC 对比

        axes[0].plot(

            t, SOC,

            color=color,

            linestyle=ls,

            linewidth=2,

            label=f"{scenario['name']} (续航 {result['summary']['time_to_empty_h']:.1f}h)",

        )

  

        # 温度对比

        axes[1].plot(

            t, T_C,

            color=color,

            linestyle=ls,

            linewidth=2,

            label=f"{scenario['name']} (最高 {result['summary']['max_temp_C']:.1f}°C)",

        )

  

    # ========================

    # SOC 图设置

    # ========================

    axes[0].set_ylabel("荷电状态 SOC (%)", fontsize=12)

    axes[0].set_ylim([0, 105])

    axes[0].grid(True, alpha=0.3)

    axes[0].legend(loc="upper right", fontsize=10)

    axes[0].set_title("不同使用场景 SOC 对比", fontsize=13, fontweight="bold")

  

    # ========================

    # 温度图设置

    # ========================

    axes[1].set_ylabel("温度 (°C)", fontsize=12)

    axes[1].set_xlabel("时间 (小时)", fontsize=12)

    axes[1].grid(True, alpha=0.3)

    axes[1].legend(loc="upper right", fontsize=10)

    axes[1].set_title("不同使用场景温度对比", fontsize=13, fontweight="bold")

  

    fig.suptitle(

        "智能手机电池寿命仿真 - 多场景对比",

        fontsize=14,

        fontweight="bold",

        y=1.02,

    )

  

    plt.tight_layout()

  

    # 保存图片

    filepath = os.path.join(output_dir, "scenario_comparison.png")

    plt.savefig(filepath, dpi=150, bbox_inches="tight")

    plt.close(fig)

  

    return filepath

  
  

def print_summary_table(all_results: Dict[str, Dict[str, Any]]) -> None:

    """

    在控制台打印结果摘要表格。

    """

    print("\n" + "=" * 80)

    print("仿真结果摘要")

    print("=" * 80)

    print(f"{'场景':<25} {'续航(h)':<10} {'最高温(°C)':<12} {'最低温(°C)':<12} {'平均电流(A)':<12}")

    print("-" * 80)

  

    for label, result in all_results.items():

        s = result["summary"]

        name = result["scenario"]["name"]

        print(

            f"{name:<25} "

            f"{s['time_to_empty_h']:<10.2f} "

            f"{s['max_temp_C']:<12.1f} "

            f"{s['min_temp_C']:<12.1f} "

            f"{s['avg_current_A']:<12.3f}"

        )

  

    print("=" * 80)

  
  

# ================================================================================

# 第六部分：主程序入口

# ================================================================================

  

if __name__ == "__main__":

    # 配置中文字体

    configure_chinese_font()

  

    # 获取输出目录

    output_dir = get_output_dir()

    print(f"结果将保存至: {output_dir}")

  

    # ========================

    # 运行三种场景仿真

    # ========================

    scenarios = {

        "Case_A": "case_a",  # 办公场景

        "Case_B": "case_b",  # 游戏场景

        "Case_C": "case_c",  # 极寒场景

    }

  

    all_results: Dict[str, Dict[str, Any]] = {}

  

    for label, scenario_key in scenarios.items():

        print(f"\n正在仿真: {label} ({SCENARIO_PROFILES[scenario_key]['name']})...")

        result = run_simulation(scenario_key=scenario_key, seed=42)

        all_results[label] = result

  

        # 绘制单场景详细图

        fig_path = plot_single_scenario(result, output_dir, label)

        print(f"  -> 详细图已保存: {fig_path}")

  

    # ========================

    # 绘制对比图

    # ========================

    print("\n正在生成对比图...")

    comparison_path = plot_comparison(all_results, output_dir)

    print(f"  -> 对比图已保存: {comparison_path}")

  

    # ========================

    # 保存结果摘要

    # ========================

    json_path = save_results_to_json(all_results, output_dir)

    print(f"  -> JSON 摘要已保存: {json_path}")

  

    # ========================

    # 打印摘要表格

    # ========================

    print_summary_table(all_results)

  

    print("\n仿真完成！")
```

```
正在仿真: Case_A (办公场景 (Case A))...
[DEBUG] 电压崩溃! SOC=0.1264, T=302.52K
        Voc=3.16V, R=0.4351Ω, P_total=5.82W
        Voc²=10.02, 4RP=10.12
        判别式=-0.1081 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=0.1264, T=302.52K
        Voc=3.16V, R=0.4350Ω, P_total=5.82W
        Voc²=10.02, 4RP=10.12
        判别式=-0.1056 (需 > 0 才能正常工作)
  -> 详细图已保存: e:\python\pythonProject2\anything\26美赛\simulation_results\Case_A_detailed.png

正在仿真: Case_B (游戏场景 (Case B))...
[DEBUG] 电压崩溃! SOC=0.1410, T=320.52K
        Voc=3.20V, R=0.3520Ω, P_total=8.41W
        Voc²=10.23, 4RP=11.84
        判别式=-1.6099 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=0.1411, T=320.51K
        Voc=3.20V, R=0.3515Ω, P_total=8.41W
        Voc²=10.23, 4RP=11.82
        判别式=-1.5896 (需 > 0 才能正常工作)
  -> 详细图已保存: e:\python\pythonProject2\anything\26美赛\simulation_results\Case_B_detailed.png

正在仿真: Case_C (极寒场景 (Case C))...
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
[DEBUG] 电压崩溃! SOC=1.0000, T=263.15K
        Voc=3.90V, R=0.5849Ω, P_total=7.16W
        Voc²=15.17, 4RP=16.76
        判别式=-1.5816 (需 > 0 才能正常工作)
  -> 详细图已保存: e:\python\pythonProject2\anything\26美赛\simulation_results\Case_C_detailed.png

正在生成对比图...
  -> 对比图已保存: e:\python\pythonProject2\anything\26美赛\simulation_results\scenario_comparison.png
  -> JSON 摘要已保存: e:\python\pythonProject2\anything\26美赛\simulation_results\simulation_summary.json

================================================================================
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
办公场景 (Case A)             2.98       29.4         25.0         1.011
游戏场景 (Case B)             1.17       47.3         35.0         2.419
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
办公场景 (Case A)             2.98       29.4         25.0         1.011
游戏场景 (Case B)             1.17       47.3         35.0         2.419
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
办公场景 (Case A)             2.98       29.4         25.0         1.011
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
办公场景 (Case A)             2.98       29.4         25.0         1.011
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
仿真结果摘要
================================================================================
场景                        续航(h)      最高温(°C)      最低温(°C)      平均电流(A)
--------------------------------------------------------------------------------
办公场景 (Case A)             2.98       29.4         25.0         1.011
游戏场景 (Case B)             1.17       47.3         35.0         2.419
极寒场景 (Case C)             0.00       -10.0        -10.0        0.000
================================================================================
```