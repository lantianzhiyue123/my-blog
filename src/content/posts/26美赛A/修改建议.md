基于您提供的新 OCV 模型和系数，您的 **V3 代码**（`moudle_v3.py`）需要进行以下核心修改，以确保物理特性的准确性和数值计算的稳定性：

### 1. 修改 `BATTERY_CONFIG` 中的参数结构

原代码中的 `ocv_coeffs` 是一个为 `np.polyval` 设计的简单多项式列表 。新模型引入了对数项（$\ln$）和指数项（$\exp$），因此建议将参数改为字典形式，以便清晰对应。

**修改位置：** 附近

Python

```
# 将原有的 "ocv_coeffs": [0.6, -0.4, 0.87, 3.4] 替换为：
"ocv_params": {
    "a": 4.06604823,
    "b": -1.52460086,
    "c": 1.91129899,
    "d": -0.68008487,
    "e": 0.25735421,  # ln(SOC) 项
    "f": -0.04142781, # ln(1-SOC) 项
    "g": -0.12824626, # exp(-30*SOC) 项
},
```

---

### 2. 修改 `BatterySystem.ocv` 方法

新模型不再是简单的多项式，必须手动实现复杂的解析式。

**修改位置：**

Python

```
def ocv(self, soc: float) -> float:
    """
    计算开路电压 (OCV) - 增强型物理模型
    模型包含：多项式(a-d) + 低电量跳水(e) + 高电量饱和(f) + 初始电压修正(g)
    """
    # 核心修改：极其关键的数值保护！！
    # 因为 ln(soc) 在 soc=0 会变成负无穷，ln(1-soc) 在 soc=1 会变成负无穷
    # 必须将 soc 限制在一个微小的安全区间内（如 0.0001 到 0.9999）
    s = np.clip(soc, 1e-4, 1 - 1e-4)
    
    p = self.config["ocv_params"]
    
    # 实现新公式：
    # V = a + b*s + c*s^2 + d*s^3 + e*ln(s) + f*ln(1-s) + g*exp(-30*s)
    v_oc = (p["a"] + 
            p["b"] * s + 
            p["c"] * (s**2) + 
            p["d"] * (s**3) + 
            p["e"] * np.log(s) + 
            p["f"] * np.log(1 - s) + 
            p["g"] * np.exp(-30 * s))
            
    return float(v_oc)
```

---

### 3. 修改 `__post_init__` 中的参数解包

如果您在配置区修改了键名，初始化部分也需要对应。

**修改位置：**

Python

```
# 将 self.ocv_coeffs = self.config["ocv_coeffs"] 替换或删除
# 如果使用了上面的字典结构，确保 ocv 方法能通过 self.config["ocv_params"] 访问到数据
```

---

### 为什么这些修改至关重要？

- **捕捉“快速掉电 (Rapid Drain)”**：新增的 `e * ln(s)` 项和 `g * exp(-30*s)` 项是解决您之前提到的“SOC 曲线太直”问题的关键。当 SOC 降至 0.1 以下时，这些项会导致电压急剧下降，从而触发电流暴增的物理正反馈，让 SOC 曲线产生明显的末端跳水 。

- **数值安全性**：对数函数 $\ln(0)$ 和 $\ln(1-1)$ 是数值计算的死穴。原代码中的 `np.clip(soc, 0.0, 1.0)` 必须修正为 `1e-4` 等微小量，否则程序会因为产生 `NaN` 或 `inf` 而在仿真中途崩溃。
    
- **电压崩溃判据的联动**：由于新公式在低 SOC 时电压跌落更猛烈，您的 `solve_current` 方法中的判别式 $\Delta = V_{oc}^2 - 4RP$ 会更早、更真实地触发“电压崩溃” ，这能完美复现寒冷天气下（$R$ 增大）手机在还有 10%-20% 电量时突然关机的物理现象 。


